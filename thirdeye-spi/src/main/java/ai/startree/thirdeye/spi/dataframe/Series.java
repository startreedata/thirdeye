/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package ai.startree.thirdeye.spi.dataframe;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.List;
import org.apache.commons.lang3.ArrayUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Period;

/**
 * Container for a one-dimensional series of elements with a common primitive type.
 * Supports transparent conversion between different primitive types and implements
 * common logic for element management, transformation and aggregation.
 *
 * Series are designed to be immutable (albeit with some limitations due to Java's
 * primitive array model). Operations return new Series instances without modifying
 * the underlying data structures.
 */
public abstract class Series {

  private static final String IS_EMPTY = "Series is empty";
  private static final String IS_NULL = "Value is null";
  private static final String ONE_ELEMENT = "Series must contain exactly one element";
  private static final String NOT_SUPPORTED = "Operation not supported";

  public static final String TOSTRING_NULL = "null";

  public enum SeriesType {
    DOUBLE,
    LONG,
    STRING,
    BOOLEAN,
    OBJECT
  }

  enum JoinType {
    INNER,
    OUTER,
    LEFT,
    RIGHT
  }

  /**
   * Top-level interface to denote a function that may be applied to one (or multiple) series.
   * Functions may be applied either row-by-row across multiple series or to all values within
   * a single series.
   * <br/><b>NOTE:</b> Functions MAY NOT receive a {@code null} value as an input. Rather, if
   * any one of the input values is {@code null}, the result is set to {@code null} by the
   * Series framework.
   * <br/><b>NOTE:</b> Function MAY return {@code null} as a result, however.
   */
  public interface Function {
    // left blank
  }

  public interface Conditional extends Function {
    // left blank
  }

  //  @FunctionalInterface
  public interface DoubleConditional extends Conditional {

    boolean apply(double... values);
  }

  //  @FunctionalInterface
  public interface LongConditional extends Conditional {

    boolean apply(long... values);
  }

  //  @FunctionalInterface
  public interface StringConditional extends Conditional {

    boolean apply(String... values);
  }

  //  @FunctionalInterface
  public interface BooleanConditional extends Conditional {

    boolean apply(boolean... values);
  }

  //  @FunctionalInterface
  public interface ObjectConditional extends Conditional {

    boolean apply(Object... values);
  }

  //  @FunctionalInterface
  public interface DoubleFunction extends Function {

    double NULL = DoubleSeries.NULL;

    double apply(double... values);
  }

  //  @FunctionalInterface
  public interface LongFunction extends Function {

    long NULL = LongSeries.NULL;

    long apply(long... values);
  }

  //  @FunctionalInterface
  public interface StringFunction extends Function {

    String NULL = StringSeries.NULL;

    String apply(String... values);
  }

  //  @FunctionalInterface
  public interface BooleanFunction extends Function {

    boolean apply(boolean... values);
  }

  //  @FunctionalInterface
  public interface BooleanFunctionEx extends Function {

    byte TRUE = BooleanSeries.TRUE;
    byte FALSE = BooleanSeries.FALSE;
    byte NULL = BooleanSeries.NULL;

    byte apply(byte... values);
  }

  //  @FunctionalInterface
  public interface ObjectFunction extends Function {

    Object apply(Object... values);
  }

  /**
   * Base class for specialized Series builders
   */
  public static abstract class Builder {

    public abstract Series build();

    public abstract Builder addSeries(Collection<Series> series);

    public Builder addSeries(Series... series) {
      return this.addSeries(Arrays.asList(series));
    }
  }

  /**
   * Helper container for index-pairs generated by join logic
   */
  static final class JoinPairs {

    private static final long TO_LONG = 0xFFFFFFFFL;
    private static final int MIN_CAPACITY = 1;

    int size = 0;
    long[] pairs;

    public JoinPairs(int initialCapacity) {
      this.pairs = new long[Math.max(initialCapacity, MIN_CAPACITY)];
    }

    public int size() {
      return this.size;
    }

    public int left(int index) {
      return (int) (this.pairs[index] >>> 32);
    }

    public int right(int index) {
      return (int) this.pairs[index];
    }

    public long get(int index) {
      return this.pairs[index];
    }

    public JoinPairs add(int left, int right) {
      return this.add(((left & TO_LONG) << 32) | (right & TO_LONG));
    }

    public JoinPairs add(long pair) {
      if (this.size >= this.pairs.length) {
        long[] newBuffer = new long[this.pairs.length * 2];
        System.arraycopy(this.pairs, 0, newBuffer, 0, this.pairs.length);
        this.pairs = newBuffer;
      }
      this.pairs[this.size++] = pair;
      return this;
    }
  }

  /* *************************************************************************
   * Public abstract interface
   * *************************************************************************/

  /**
   * Returns the number of elements contained in the series.
   *
   * <br/><b>NOTE:</b> {@code null} values count as elements.
   *
   * @return series size
   */
  public abstract int size();

  /**
   * Returns the series' native type.
   *
   * @return series type
   */
  public abstract SeriesType type();

  /**
   * Slices the series from index {@code from} (inclusive) to index {@code to}
   * (exclusive) and returns the result as a series of the same native type.
   *
   * @param from start index (inclusive), must be >= 0
   * @param to end index (exclusive), must be <= size
   * @return sliced series copy
   */
  public abstract Series slice(int from, int to);

  /**
   * Returns the value referenced by {@code index} as double. The value is converted
   * transparently if the native type of the underlying series is different. The
   * {@code index} must be between {@code 0} and the size of the series.
   *
   * @param index index of value
   * @return double value
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract double getDouble(int index);

  /**
   * Returns the value referenced by {@code index} as long. The value is converted
   * transparently if the native type of the underlying series is different. The
   * {@code index} must be between {@code 0} and the size of the series.
   *
   * @param index index of value
   * @return long value
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract long getLong(int index);

  /**
   * Returns the value referenced by {@code index} as byte (tri-state boolean).
   * The value is converted transparently if the native type of the underlying
   * series is different. The {@code index} must be between {@code 0} and the
   * size of the series.
   *
   * @param index index of value
   * @return byte value
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract byte getBoolean(int index);

  /**
   * Returns the value referenced by {@code index} as String. The value is converted
   * transparently if the native type of the underlying series is different. The
   * {@code index} must be between {@code 0} and the size of the series.
   *
   * @param index index of value
   * @return string value
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract String getString(int index);

  /**
   * Returns the value referenced by {@code index} as Object. The value is converted
   * transparently if the native type of the underlying series is different. The
   * {@code index} must be between {@code 0} and the size of the series.
   *
   * @param index index of value
   * @return object value
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract Object getObject(int index);

  /**
   * Returns {@code true} if the value referenced by {@code index} is null. Otherwise,
   * returns {@code false}.
   *
   * @param index index of value
   * @return {@code true} if value is null, otherwise {@code false}
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract boolean isNull(int index);

  /**
   * Returns a human-readable String representation of the value referenced by {@code index}.
   *
   * @param index index of value
   * @return human-readable string representation
   * @throws IndexOutOfBoundsException if index is outside the series bounds
   */
  public abstract String toString(int index);

  /**
   * Returns a copy of the series with values ordered in ascending order.
   *
   * <br/><b>NOTE:</b> BooleanSeries interprets {@code false} as smaller than {@code true}.
   *
   * @return sorted series copy
   */
  public abstract Series sorted();

  /**
   * Returns a copy of the series with {@code null} values replaced by the series' default
   * value.
   *
   * @return series copy with filled nulls
   */
  public abstract Series fillNull();

  /**
   * Returns a new builder instance for the native type encapsulated by this series.
   *
   * @return series builder
   */
  public abstract Builder getBuilder();

  /**
   * Returns a copy of the series with values replaced by {@code null} for every row in
   * {@code filter} that is not {@code true}.
   *
   * @param mask series to filter by
   * @return filtered series copy
   */
  public abstract Series filter(BooleanSeries mask);

  /**
   * Returns a copy of the series with all values' indices
   * shifted by {@code offset} positions while
   * leaving the series size unchanged. Values shifted outside to upper (or lower)
   * bounds of the series are dropped. Vacated positions are padded with {@code null}.
   *
   * <br/><b>NOTE:</b> for each value, newIndex = oldIndex + offset
   *
   * @param offset offset to shift values by. Can be positive or negative.
   * @return shifted series copy
   */
  public abstract Series shift(int offset);

  /**
   * Returns a copy of the series with all values indicated by {@code mask} replace by the
   * corresponding values in {@code other}. If {@code other} has only a single element,
   * all values indicated by mask are replaced by the this single value. Otherwise, the
   * series, {@code mask} and {@code other} must be of the same length.
   *
   * @param mask boolean
   * @param other replacement values
   * @return series copy with masked values replaced by values from {@code other}
   */
  public abstract Series set(BooleanSeries mask, Series other);

  /* *************************************************************************
   * Public optional operations
   * *************************************************************************/

  public Series first() {
    if (this.isEmpty()) {
      throw new IllegalStateException(IS_EMPTY);
    }
    return this.sliceTo(1);
  }

  public Series last() {
    if (this.isEmpty()) {
      throw new IllegalStateException(IS_EMPTY);
    }
    return this.sliceFrom(this.size() - 1);
  }

  public Series sum() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series product() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series min() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series max() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series mean() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series median() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  public Series std() {
    throw new RuntimeException(NOT_SUPPORTED);
  }

  /**
   * Returns the primitive double representation of a single value series.
   *
   * @return double value
   * @throws IllegalStateException if the series does not contain exactly one element, or the
   *     value is {@code NULL}.
   */
  public final double doubleValue() {
    return assertSingleValue().getDouble(0);
  }

  /**
   * Returns the primitive long representation of a single value series.
   *
   * @return long value
   * @throws IllegalStateException if the series does not contain exactly one element, or the
   *     value is {@code NULL}.
   */
  public final long longValue() {
    return assertSingleValue().getLong(0);
  }

  /**
   * Returns the primitive boolean representation of a single value series.
   *
   * @return boolean value
   * @throws IllegalStateException if the series does not contain exactly one element, or the
   *     value is {@code NULL}.
   */
  public final boolean booleanValue() {
    return BooleanSeries.booleanValueOf(assertSingleValue().getBoolean(0));
  }

  /**
   * Returns the string representation of a single value series.
   *
   * @return string value
   * @throws IllegalStateException if the series does not contain exactly one element, or the
   *     value is {@code NULL}.
   */
  public final String stringValue() {
    return assertSingleValue().getString(0);
  }

  /**
   * Returns the object representation of a single value series.
   *
   * @return object value
   * @throws IllegalStateException if the series does not contain exactly one element, or the
   *     value is {@code NULL}.
   */
  public final Object objectValue() {
    return assertSingleValue().getObject(0);
  }

  private Series assertSingleValue() {
    if (this.size() != 1) {
      throw new IllegalStateException(ONE_ELEMENT);
    }
    if (this.isNull(0)) {
      throw new IllegalStateException(IS_NULL);
    }
    return this;
  }

  /* *************************************************************************
   * Internal abstract interface
   * *************************************************************************/

  /**
   * Returns projection of the series.
   *
   * <br/><b>NOTE:</b> fromIndex <= -1 is filled with {@code null}.
   * <br/><b>NOTE:</b> array with length 0 returns empty series.
   * <br/><b>NOTE:</b> could replace {@code slice(int, int)}, but low performance
   *
   * @param fromIndex array with indices to project from (must be <= series size)
   * @return series projection
   */
  abstract Series project(int[] fromIndex);

  /**
   * Compares values across two series with potentially different native types based on index.
   * If the types are different the values in {@code that} are transparently converted to the
   * native type of this series.
   *
   * <br/><b>Note:</b> the transparent conversion may cause different behavior between
   * {@code this.compare(that)} and {@code that.compare(this)}.
   *
   * @param that other series with same native type (may reference itself)
   * @param indexThis index in this series
   * @param indexThat index in the other series
   * @return 0 if the referenced values are equal, -1 if {@code this} is less than {@code that}, 1
   *     otherwise
   */
  abstract int compare(Series that, int indexThis, int indexThat);

  /**
   * Returns an array of indices with a size equal to the series size, such that the values
   * references by the indices are sorted in ascending order.
   *
   * <br/><b>NOTE:</b> output can be used directly by {@code project()} to create a sorted copy of
   * the series.
   *
   * @return indices of sorted values
   */
  abstract int[] sortedIndex();

//  /**
//   * Returns a hashCode representation of the underlying value. <i>Should</i> be unique, but
//   * <i>need not</i> be unique. Used for hash join.
//   *
//   * @param index value index
//   * @return hash code representation of value
//   */
//  abstract long hashCode(int index);

  /**
   * Compares values for equality across two series with potentially different types based on
   * index. If the types are different the values in {@code that} are transparently converted to the
   * native type of this series.
   *
   * <br/><b>Note:</b> the transparent conversion may cause different behavior between
   * {@code this.compare(that)} and {@code that.compare(this)}.
   *
   * @param that other series with same native type (may reference itself)
   * @param indexThis index in this series
   * @param indexThat index in the other series
   * @return {@code true} if the referenced values are equal, {@code false} otherwise
   */
  boolean equals(Series that, int indexThis, int indexThat) {
    return this.compare(that, indexThis, indexThat) == 0;
  }

  int hashCode(int index) {
    return this.getObject(index).hashCode();
  }

  /* *************************************************************************
   * Public interface
   * *************************************************************************/

  /**
   * Returns series {@code s} converted to type {@code type} unless native type matches already.
   *
   * @param type target type
   * @return converted series
   */
  public final Series get(Series.SeriesType type) {
    switch (type) {
      case DOUBLE:
        return this.getDoubles();
      case LONG:
        return this.getLongs();
      case BOOLEAN:
        return this.getBooleans();
      case STRING:
        return this.getStrings();
      case OBJECT:
        return this.getObjects();
      default:
        throw new IllegalArgumentException(String.format("Unknown series type '%s'", type));
    }
  }

  /**
   * Returns a the series as DoubleSeries. The underlying series is converted
   * transparently if the series' native type is different.
   *
   * @return DoubleSeries equivalent
   */
  public DoubleSeries getDoubles() {
    double[] values = new double[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = this.getDouble(i);
    }
    return DoubleSeries.buildFrom(values);
  }

  /**
   * Returns the series as LongSeries. The underlying series is converted
   * transparently if the series' native type is different.
   *
   * @return LongSeries equivalent
   */
  public LongSeries getLongs() {
    long[] values = new long[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = this.getLong(i);
    }
    return LongSeries.buildFrom(values);
  }

  /**
   * Returns the series as BooleanSeries. The underlying series is converted
   * transparently if the series' native type is different.
   *
   * @return BooleanSeries equivalent
   */
  public BooleanSeries getBooleans() {
    byte[] values = new byte[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = this.getBoolean(i);
    }
    return BooleanSeries.buildFrom(values);
  }

  /**
   * Returns the series as StringSeries. The underlying series is converted
   * transparently if the series' native type is different.
   *
   * @return StringSeries equivalent
   */
  public StringSeries getStrings() {
    String[] values = new String[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = this.getString(i);
    }
    return StringSeries.buildFrom(values);
  }

  /**
   * Returns the series as ObjectSeries. The underlying series is converted
   * transparently if the series' native type is different.
   *
   * @return StringSeries equivalent
   */
  public ObjectSeries getObjects() {
    Object[] values = new Object[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = this.getObject(i);
    }
    return ObjectSeries.buildFrom(values);
  }

  /**
   * Returns as copy of the series with the same native type.
   *
   * @return series copy
   */
  public Series copy() {
    return this.slice(0, this.size());
  }

  /**
   * Returns a copy of the series with values from {@code other}
   * appended at the end. If {@code other} has different native types they are
   * converted transparently.
   *
   * <br/><b>NOTE:</b> newSize = oldSize + otherSize
   *
   * @param other other series to append at the end
   * @return concatenated series
   */
  public Series append(Series... other) {
    return this.getBuilder().addSeries(this).addSeries(other).build();
  }

  /**
   * Returns a copy of the series with all values replaced non-null values from {@code other}.
   *
   * @param other replacement values
   * @return series copy with values replaced by non-null values from {@code other}
   * @see Series#set(BooleanSeries, Series)
   */
  public Series set(Series other) {
    return this.set(other.isNull().not(), other);
  }

  /**
   * Fills {@code null} values in the series with a copy of the last valid value. The index
   * is traversed in ascending order. If the last valid value does not exist (such as for the
   * first element in a series) it is left at {@code null}.
   *
   * @return forward filled series
   */
  public Series fillNullForward() {
    int lastValueIndex = -1;
    int[] fromIndex = new int[this.size()];
    for (int i = 0; i < this.size(); i++) {
      if (!isNull(i)) {
        lastValueIndex = i;
      }
      fromIndex[i] = lastValueIndex;
    }
    return this.project(fromIndex);
  }

  /**
   * Fills {@code null} values in the series with a copy of the last valid value. The index
   * is traversed in descending order. If the last valid value does not exist (such as for the
   * last element in a series) it is left at {@code null}.
   *
   * @return backward filled series
   */
  public Series fillNullBackward() {
    int lastValueIndex = -1;
    int[] fromIndex = new int[this.size()];
    for (int i = this.size() - 1; i >= 0; i--) {
      if (!isNull(i)) {
        lastValueIndex = i;
      }
      fromIndex[i] = lastValueIndex;
    }
    return this.project(fromIndex);
  }

  /**
   * Returns {@code true} is there are no values in the series. Otherwise returns {@code false}.
   *
   * <br/><b>NOTE:</b> {@code null} values count as elements.
   *
   * @return {@code true} if empty, {@code false} otherwise
   */
  public final boolean isEmpty() {
    return this.size() <= 0;
  }

  /**
   * Returns {@code true} if the series contains at least one {@code null}. Otherwise
   * returns {@code false}.
   *
   * @return {@code true} if empty, {@code false} otherwise
   */
  public final boolean hasNull() {
    for (int i = 0; i < this.size(); i++) {
      if (this.isNull(i)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns {@code true} if the series contains only {@code null} values or is empty.
   *
   * @return {@code true} if all null or empty, {@code false} otherwise.
   */
  public final boolean allNull() {
    for (int i = 0; i < this.size(); i++) {
      if (!this.isNull(i)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Returns the number of non-null values in the series.
   *
   * @return count of non-null values
   */
  public final int count() {
    int countNotNull = 0;
    for (int i = 0; i < this.size(); i++) {
      if (!this.isNull(i)) {
        countNotNull++;
      }
    }
    return countNotNull;
  }

  /**
   * Returns a copy of the series containing at maximum the first {@code n} elements of the series.
   * If {@code n} is larger than the series size, the entire series is returned. Additional values
   * to make up the difference between {@code n} and the size are not padded.
   *
   * @param n number of elements
   * @return series copy with at most the first {@code n} elements
   */
  public Series head(int n) {
    return this.slice(0, Math.min(n, this.size()));
  }

  /**
   * Returns a copy of the series containing at maximum the last {@code n} elements of the series.
   * If {@code n} is larger than the series size, the entire series is returned. Additional values
   * to make up the difference between {@code n} and the size are not padded.
   *
   * @param n number of elements
   * @return series copy with at most the last {@code n} elements
   */
  public Series tail(int n) {
    int len = this.size();
    return this.slice(len - Math.min(n, len), len);
  }

  /**
   * Returns a copy of the series omitting any elements before index {@code n}.
   * If {@code n} is {@code 0}, the entire series is returned. If {@code n} is greater than
   * the series size, an empty series is returned.
   *
   * @param from start index of copy (inclusive)
   * @return series copy with elements from index {@code from}.
   */
  public Series sliceFrom(int from) {
    return this.slice(Math.max(from, 0), this.size());
  }

  /**
   * Returns a copy of the series omitting any elements equal to or after index {@code n}.
   * If {@code n} is equal or greater than the series size, the entire series is returned.
   * If {@code n} is {@code 0}, an empty series is returned.
   *
   * @param to end index of copy (exclusive)
   * @return series copy with elements before from index {@code from}.
   */
  public Series sliceTo(int to) {
    return this.slice(0, Math.min(to, this.size()));
  }

  /**
   * Returns a copy of the series with elements in reverse order from the original series.
   *
   * @return reversed series
   */
  public Series reverse() {
    int[] fromIndex = new int[this.size()];
    for (int i = 0; i < fromIndex.length; i++) {
      fromIndex[i] = fromIndex.length - i - 1;
    }
    return this.project(fromIndex);
  }

  /**
   * Returns a copy of the series with each distinct value of the
   * source series appearing exactly once.
   *
   * <br/><b>NOTE:</b> the values may be reordered
   *
   * @return series copy with distinct unique values
   */
  public Series unique() {
    if (this.size() <= 1) {
      return this;
    }

    Series sorted = this.sorted();
    List<Integer> indices = new ArrayList<>();

    indices.add(0);
    for (int i = 1; i < this.size(); i++) {
      if (!sorted.equals(sorted, i - 1, i)) {
        indices.add(i);
      }
    }

    int[] fromIndex = ArrayUtils.toPrimitive(indices.toArray(new Integer[indices.size()]));
    return sorted.project(fromIndex);
  }

  /**
   * Returns a copy of the series omitting any {@code null} values.
   *
   * @return series copy without {@code nulls}
   */
  public Series dropNull() {
    if (!this.hasNull()) {
      return this;
    }
    int[] fromIndex = new int[this.size()];
    int count = 0;
    for (int i = 0; i < this.size(); i++) {
      if (!isNull(i)) {
        fromIndex[count++] = i;
      }
    }
    return this.project(Arrays.copyOf(fromIndex, count));
  }

  /**
   * Returns a BooleanSeries which contains a value indicating the null-equivalence for each
   * value in the original series (this).
   *
   * @return boolean series indicating null-equivalence of each value
   */
  public BooleanSeries isNull() {
    byte[] values = new byte[this.size()];
    for (int i = 0; i < this.size(); i++) {
      values[i] = BooleanSeries.valueOf(this.isNull(i));
    }
    return BooleanSeries.buildFrom(values);
  }

  /**
   * Returns a copy of the series with values replaced by {@code null} for every row in
   * the result of applying {@code conditional} to the series that is not {@code true}.
   *
   * @param conditional conditional to apply and filter by
   * @return filtered series copy
   */
  public Series filter(Conditional conditional) {
    return this.filter(this.map(conditional));
  }

  //
  // NOTE: co-variant method messiness
  //

  /**
   * Applies {@code function} to the series row by row and returns the results as a new series.
   * If the series' native types do not match the required input type of {@code function},
   * the series are converted transparently. The native type of the returned series is
   * determined by {@code function}'s output type.
   *
   * @param function function to apply to each row
   * @param series series to apply function to
   * @return series with evaluation results
   */
  public static Series map(Function function, Series... series) {
    if (function instanceof DoubleFunction) {
      return DoubleSeries.map((DoubleFunction) function, series);
    } else if (function instanceof LongFunction) {
      return LongSeries.map((LongFunction) function, series);
    } else if (function instanceof StringFunction) {
      return StringSeries.map((StringFunction) function, series);
    } else if (function instanceof BooleanFunction) {
      return BooleanSeries.map((BooleanFunction) function, series);
    } else if (function instanceof BooleanFunctionEx) {
      return BooleanSeries.map((BooleanFunctionEx) function, series);
    } else if (function instanceof ObjectFunction) {
      return ObjectSeries.map((ObjectFunction) function, series);
    } else if (function instanceof DoubleConditional) {
      return DoubleSeries.map((DoubleConditional) function, series);
    } else if (function instanceof LongConditional) {
      return LongSeries.map((LongConditional) function, series);
    } else if (function instanceof StringConditional) {
      return StringSeries.map((StringConditional) function, series);
    } else if (function instanceof BooleanConditional) {
      return BooleanSeries.map((BooleanConditional) function, series);
    } else if (function instanceof ObjectConditional) {
      return ObjectSeries.map((ObjectConditional) function, series);
    }
    throw new IllegalArgumentException(
        String.format("Unknown function type '%s'", function.getClass()));
  }

  /**
   * Applies {@code function} to the series row by row and returns the results as a new series.
   * If the series' native type does not match the required input type of {@code function},
   * the series is converted transparently. The native type of the returned series is
   * determined by {@code function}'s output type.
   *
   * @param function function to map to each element in the series
   * @return series with evaluation results
   */
  public final Series map(Function function) {
    return map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final DoubleSeries map(DoubleFunction function) {
    return (DoubleSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final LongSeries map(LongFunction function) {
    return (LongSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final StringSeries map(StringFunction function) {
    return (StringSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final BooleanSeries map(BooleanFunction function) {
    return (BooleanSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final BooleanSeries map(BooleanFunctionEx function) {
    return (BooleanSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final ObjectSeries map(ObjectFunction function) {
    return (ObjectSeries) map(function, this);
  }

  /**
   * @see Series#map(Function)
   */
  public final BooleanSeries map(Conditional conditional) {
    return (BooleanSeries) map(conditional, this);
  }

  //
  // NOTE: co-variant method messiness
  //

  /**
   * Applies {@code function} as aggregation function to all values in the series at once and
   * returns the result as a new series with a single element.
   * If the series' native type does not match the required input type of {@code function},
   * the series is converted transparently. The native type of the returned series is
   * determined by {@code function}'s output type.
   *
   * @param function aggregation function to map to the series
   * @return single element series
   */
  public final Series aggregate(Function function) {
    if (function instanceof DoubleFunction) {
      return DoubleSeries.aggregate((DoubleFunction) function, this);
    } else if (function instanceof LongFunction) {
      return LongSeries.aggregate((LongFunction) function, this);
    } else if (function instanceof StringFunction) {
      return StringSeries.aggregate((StringFunction) function, this);
    } else if (function instanceof BooleanFunction) {
      return BooleanSeries.aggregate((BooleanFunction) function, this);
    } else if (function instanceof BooleanFunctionEx) {
      return BooleanSeries.aggregate((BooleanFunctionEx) function, this);
    } else if (function instanceof ObjectFunction) {
      return ObjectSeries.aggregate((ObjectFunction) function, this);
    } else if (function instanceof DoubleConditional) {
      return DoubleSeries.aggregate((DoubleConditional) function, this);
    } else if (function instanceof LongConditional) {
      return LongSeries.aggregate((LongConditional) function, this);
    } else if (function instanceof StringConditional) {
      return StringSeries.aggregate((StringConditional) function, this);
    } else if (function instanceof BooleanConditional) {
      return BooleanSeries.aggregate((BooleanConditional) function, this);
    } else if (function instanceof ObjectConditional) {
      return ObjectSeries.aggregate((ObjectConditional) function, this);
    }
    throw new IllegalArgumentException(
        String.format("Unknown function type '%s'", function.getClass()));
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final DoubleSeries aggregate(DoubleFunction function) {
    return (DoubleSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final LongSeries aggregate(LongFunction function) {
    return (LongSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final StringSeries aggregate(StringFunction function) {
    return (StringSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final BooleanSeries aggregate(BooleanFunction function) {
    return (BooleanSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final BooleanSeries aggregate(BooleanFunctionEx function) {
    return (BooleanSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final ObjectSeries aggregate(ObjectFunction function) {
    return (ObjectSeries) this.aggregate((Function) function);
  }

  /**
   * @see Series#aggregate(Function)
   */
  public final BooleanSeries aggregate(Conditional conditional) {
    return (BooleanSeries) this.aggregate((Function) conditional);
  }

  /**
   * Returns a concatenation of {@code series} as a new series with a native type equal
   * to the first series. If subsequent series have different native types they are
   * converted transparently.
   *
   * @param series series to concatenate
   * @return concatenated series
   */
  public static Series concatenate(Series... series) {
    if (series.length <= 0) {
      throw new IllegalArgumentException("Must concatenate at least one series");
    }

    Series first = series[0];
    Series[] rest = Arrays.copyOfRange(series, 1, series.length);

    return first.append(rest);
  }

  /* *************************************************************************
   * Grouping
   * *************************************************************************/

  /**
   * Returns a SeriesGrouping based on the labels provided by {@code labels} row by row.
   * The size of {@code labels} must match the size of the series.
   *
   * @param labels grouping labels
   * @return SeriesGrouping
   * @see Grouping.GroupingByValue
   */
  public Grouping.SeriesGrouping groupByValue(Series labels) {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByValue.from(labels));
  }

  /**
   * Returns a SeriesGrouping based on the values of the series.
   *
   * @return SeriesGrouping
   * @see Grouping.GroupingByValue
   */
  public Grouping.SeriesGrouping groupByValue() {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByValue.from(this));
  }

  /**
   * Returns a SeriesGrouping based on the labels provided by {@code labels} row by row.
   * The size of {@code labels} must match the size of the series.
   *
   * @param labels grouping labels
   * @return SeriesGrouping
   * @see Grouping.GroupingByInterval
   */
  public Grouping.SeriesGrouping groupByInterval(Series labels, long interval) {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByInterval.from(labels, interval));
  }

  /**
   * Returns a SeriesGrouping based on the values of the series.
   *
   * @return SeriesGrouping
   * @see Grouping.GroupingByInterval
   */
  public Grouping.SeriesGrouping groupByInterval(long interval) {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByInterval.from(this, interval));
  }

  /**
   * Returns a SeriesGrouping based on items counts.
   *
   * @param count item count
   * @return SeriesGrouping
   * @see Grouping.GroupingByCount
   */
  public Grouping.SeriesGrouping groupByCount(int count) {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByCount.from(count, this.size()));
  }

  /**
   * Returns a SeriesGrouping based on partition counts.
   *
   * @param partitionCount item count
   * @return SeriesGrouping
   * @see Grouping.GroupingByPartitions
   */
  public Grouping.SeriesGrouping groupByPartitions(int partitionCount) {
    return new Grouping.SeriesGrouping(this,
        Grouping.GroupingByPartitions.from(partitionCount, this.size()));
  }

  /**
   * Returns a SeriesGrouping based on a moving window.
   *
   * @param windowSize moving window size
   * @return SeriesGrouping
   * @see Grouping.GroupingByMovingWindow
   */
  public Grouping.SeriesGrouping groupByMovingWindow(int windowSize) {
    return new Grouping.SeriesGrouping(this,
        Grouping.GroupingByMovingWindow.from(windowSize, this.size()));
  }

  /**
   * Returns a SeriesGrouping based on an expanding window.
   *
   * @return SeriesGrouping
   * @see Grouping.GroupingByExpandingWindow
   */
  public Grouping.SeriesGrouping groupByExpandingWindow() {
    return new Grouping.SeriesGrouping(this, Grouping.GroupingByExpandingWindow.from(this.size()));
  }

  /**
   * Returns a SeriesGrouping based on a time period from an origin.
   *
   * @param origin start time stamp
   * @param bucketSize time bucket size
   * @return SeriesGrouping
   * @see Grouping.GroupingByPeriod
   */
  public Grouping.SeriesGrouping groupByPeriod(DateTime origin, Period bucketSize) {
    return new Grouping.SeriesGrouping(this,
        Grouping.GroupingByPeriod.from(this.getLongs(), origin, bucketSize));
  }

  /**
   * Returns a SeriesGrouping based on a time period.
   *
   * @param timezone time zone to interpret timestamps in
   * @param bucketSize time bucket size
   * @return SeriesGrouping
   * @see Grouping.GroupingByPeriod
   */
  public Grouping.SeriesGrouping groupByPeriod(DateTimeZone timezone, Period bucketSize) {
    return new Grouping.SeriesGrouping(this,
        Grouping.GroupingByPeriod.from(this.getLongs(), timezone, bucketSize));
  }

  /* *************************************************************************
   * Internal interface
   * *************************************************************************/

  /**
   * Returns a collection of JoinPairs for an outer join performed based on hash and equality.
   * Can perform joins across multiple columns on both sides.
   *
   * @param left left side of the join
   * @param right right side of the join
   * @return JoinPairs
   * @see Series#hashCode(int)
   */
  static JoinPairs hashJoinOuter(Series[] left, Series[] right) {
    if (left.length != right.length) {
      throw new IllegalArgumentException(
          "Number of series on the left side of the join must be equal to the right side");
    }
    if (left.length <= 0) {
      throw new IllegalArgumentException("Must join on at least one series");
    }
    assertSameLength(left);
    assertSameLength(right);

    JoinPairs pairs = new JoinPairs(left[0].size());
    BitSet touchedRight = new BitSet(right[0].size());

    Series[] rightTyped = new Series[right.length];
    for (int i = 0; i < right.length; i++) {
      rightTyped[i] = right[i].get(left[i].type());
    }

    PrimitiveMultimap hashRight = new PrimitiveMultimap(rightTyped);

    for (int i = 0; i < left[0].size(); i++) {
      int[] rows = hashRight.get(left, i, rightTyped);
      if (rows.length <= 0) {
        pairs.add(i, -1);
        continue;
      }
      for (int j : rows) {
        pairs.add(i, j);
        touchedRight.set(j);
      }
    }

    for (int i = 0; i < rightTyped[0].size(); i++) {
      if (!touchedRight.get(i)) {
        pairs.add(-1, i);
      }
    }

    return pairs;
  }

  /**
   * Returns a collection of JoinPairs for an outer join performed based on hash and equality.
   * Can perform joins across multiple columns on both sides.
   *
   * @param left left side of the join
   * @param right right side of the join
   * @return JoinPairs
   * @see Series#hashCode(int)
   */
  static JoinPairs hashJoinOuterGuava(Series[] left, Series[] right) {
    if (left.length != right.length) {
      throw new IllegalArgumentException(
          "Number of series on the left side of the join must be equal to the right side");
    }
    if (left.length <= 0) {
      throw new IllegalArgumentException("Must join on at least one series");
    }
    assertSameLength(left);
    assertSameLength(right);

    JoinPairs pairs = new JoinPairs(left[0].size());
    BitSet touchedRight = new BitSet(right[0].size());

    Series[] rightTyped = new Series[right.length];
    for (int i = 0; i < right.length; i++) {
      rightTyped[i] = right[i].get(left[i].type());
    }

    Multimap<Integer, Integer> hashRight = ArrayListMultimap.create(right[0].size(), 1);
    for (int j = 0; j < right[0].size(); j++) {
      hashRight.put(PrimitiveMultimap.hashRow(rightTyped, j), j);
    }

    for (int i = 0; i < left[0].size(); i++) {
      Collection<Integer> rows = hashRight.get(PrimitiveMultimap.hashRow(left, i));
      Collection<Integer> actual = new ArrayList<>(rows.size());
      for (int r : rows) {
        if (Series.equalsMultiple(left, rightTyped, i, r)) {
          actual.add(r);
        }
      }
      if (actual.isEmpty()) {
        pairs.add(i, -1);
        continue;
      }
      for (int j : actual) {
        pairs.add(i, j);
        touchedRight.set(j);
      }
    }

    for (int i = 0; i < rightTyped[0].size(); i++) {
      if (!touchedRight.get(i)) {
        pairs.add(-1, i);
      }
    }

    return pairs;
  }

  /**
   * Returns a collection of JoinPairs for an inner join performed based on hash and equality.
   * Can perform joins across multiple columns on both sides.
   *
   * <br/><b>NOTE:</b> this is an optimized version of the outer join
   *
   * @param left left side of the join
   * @param right right side of the join
   * @return JoinPairs
   * @see Series#hashJoinOuter(Series[], Series[])
   * @see Series#hashCode(int)
   */
  static JoinPairs hashJoinInner(Series[] left, Series[] right) {
    if (left.length != right.length) {
      throw new IllegalArgumentException(
          "Number of series on the left side of the join must be equal to the right side");
    }
    if (left.length <= 0) {
      throw new IllegalArgumentException("Must join on at least one series");
    }
    assertSameLength(left);
    assertSameLength(right);

    JoinPairs pairs = new JoinPairs(left[0].size());

    Series[] rightTyped = new Series[right.length];
    for (int i = 0; i < right.length; i++) {
      rightTyped[i] = right[i].get(left[i].type());
    }

    PrimitiveMultimap hashRight = new PrimitiveMultimap(rightTyped);

    for (int i = 0; i < left[0].size(); i++) {
      for (int j : hashRight.get(left, i, rightTyped)) {
        pairs.add(i, j);
      }
    }

    return pairs;
  }

  static boolean equalsMultiple(Series[] left, Series[] right, int indexLeft, int indexRight) {
    for (int i = 0; i < left.length; i++) {
      if (!left[i].equals(right[i], indexLeft, indexRight)) {
        return false;
      }
    }
    return true;
  }

  static void assertSameLength(Series... series) {
    for (int i = 0; i < series.length - 1; i++) {
      if (series[i].size() != series[i + 1].size()) {
        throw new IllegalArgumentException("Series size must be of equal size");
      }
    }
  }

  /* **************************************************************************
   * Code grave
   ***************************************************************************/

//  // NOTE: too slow
//  public Series sorted() {
//    return this.project(this.sortedIndex());
//  }

//  // NOTE: too slow
//  int[] sortedIndex() {
//    Integer[] fromIndex = new Integer[this.size()];
//    for(int i=0; i<this.size(); i++)
//      fromIndex[i] = i;
//
//    final Series s = this;
//    Arrays.sort(fromIndex, new Comparator<Integer>() {
//      @Override
//      public int compare(Integer o1, Integer o2) {
//        return s.compare(s, o1, o2);
//      }
//    });
//
//    return ArrayUtils.toPrimitive(fromIndex);
//  }

//  // NOTE: too slow
//  public Series shift(int offset) {
//    int[] fromIndex = new int[this.size()];
//    int from = 0;
//    for(int i=0; i<Math.min(offset, this.size()); i++) {
//      fromIndex[from++] = -1;
//    }
//    for(int i=Math.max(offset, 0); i<Math.max(Math.min(this.size() + offset, this.size()), 0); i++) {
//      fromIndex[from++] = i - offset;
//    }
//    for(int i=Math.max(this.size() + offset, 0); i<this.size(); i++) {
//      fromIndex[from++] = -1;
//    }
//    return this.project(fromIndex);
//  }

//  // NOTE: requires ordering of elements, difficult for generic objects
//  List<JoinPair> mergeJoin(Series other) {
//    // NOTE: merge join
//    int[] lref = this.sortedIndex();
//    int[] rref = other.sortedIndex();
//
//    List<JoinPair> pairs = new ArrayList<>();
//    int i = 0;
//    int j = 0;
//    while(i < this.size() || j < other.size()) {
//      if(j >= other.size() || (i < this.size() && this.compare(other, lref[i], rref[j]) < 0)) {
//        pairs.add(new JoinPair(lref[i], -1));
//        i++;
//      } else if(i >= this.size() || (j < other.size() && this.compare(other, lref[i], rref[j]) > 0)) {
//        pairs.add(new JoinPair(-1, rref[j]));
//        j++;
//      } else if(i < this.size() && j < other.size()) {
//        // generate cross product
//
//        // count similar values on the left
//        int lcount = 1;
//        while(i + lcount < this.size() && this.equals(this, lref[i + lcount], lref[i + lcount - 1])) {
//          lcount++;
//        }
//
//        // count similar values on the right
//        int rcount = 1;
//        while(j + rcount < other.size() && other.equals(other, rref[j + rcount], rref[j + rcount - 1])) {
//          rcount++;
//        }
//
//        for(int l=0; l<lcount; l++) {
//          for(int r=0; r<rcount; r++) {
//            pairs.add(new JoinPair(lref[i + l], rref[j + r]));
//          }
//        }
//
//        i += lcount;
//        j += rcount;
//      }
//    }
//
//    return pairs;
//  }

//  // NOTE: too slow
//  static List<JoinPair> productJoin(Series[] left, Series[] right) {
//    if(left.length != right.length)
//      throw new IllegalArgumentException("Number of series on the left side of the join must be equal to the right side");
//    if(left.length <= 0)
//      throw new IllegalArgumentException("Must join on at least one series");
//    assertSameLength(left);
//    assertSameLength(right);
//
//    List<JoinPair> pairs = new ArrayList<>();
//    BitSet touchedRight = new BitSet(right[0].size());
//
//    for(int i=0; i<left[0].size(); i++) {
//      boolean touchedLeft = false;
//      for(int j=0; j<right[0].size(); j++) {
//        if(equalsMultiple(left, right, i, j)) {
//          pairs.add(new JoinPair(i, j));
//          touchedRight.set(j);
//          touchedLeft = true;
//        }
//      }
//
//      if(!touchedLeft) {
//        pairs.add(new JoinPair(i, -1));
//      }
//    }
//
//    for(int j=0; j<right[0].size(); j++) {
//      if(!touchedRight.get(j))
//        pairs.add(new JoinPair(-1, j));
//    }
//
//    return pairs;
//  }
}
